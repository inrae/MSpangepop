configfile: ".config/masterconfig.yaml"

import os
import yaml

output_dir = config.get("output_dir", "results/")
temp_dir= config.get("tempfile_location", "temp/")

# Retrieve memory multiplier from config
memory_multiplier = config.get("memory_multiplier", 1)

def get_input_files():
    inputs = []
    for sample in config["samples"].keys():
        chr_n = config["samples"][sample]["chr_n"]
        chromosomes = [f"{i}" for i in range(1, chr_n + 1)]
        inputs.extend([os.path.join(output_dir, f"{sample}", "pangenomes", f"chr_{chromosome}_graph.gfa") for chromosome in chromosomes])
    return inputs

rule all:
    input:
        get_input_files(),
        expand(os.path.join(output_dir, "{sample}", "info", "{sample}_MSpangepop_recap.txt"), sample=config["samples"].keys())

# This rule is uesd to create a recap file for the workflwo
rule create_recap:
    input:
        configfile= ".config/masterconfig.yaml"
    output:
        recap_file=os.path.join(output_dir, "{sample}", "info", "{sample}_MSpangepop_recap.txt")
    params:
        output_dir=os.path.join(output_dir, "{sample}","info",),
        current_run="{sample}"
    resources:
        mem_mb=lambda wildcards: int(1000),
        time="00:10:00"
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    priority: 1
    shell:
        """
        python3 workflow/scripts/recap.py {input.configfile} {params.output_dir} {params.current_run}
        """

# Check if the input file is usable if not, tell the user why
rule input_validation:
    input:
        fasta=lambda wildcards: config["samples"][wildcards.sample]["fasta_gz"]
    output:
        validation_file = temp(os.path.join(output_dir, "{sample}", temp_dir, "valid_input.tmp"))
    params:
        chr_n =lambda wildcards: config["samples"][wildcards.sample]["chr_n"]
    priority: 10
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    shell:
        """
        python3 workflow/scripts/input_validation.py --fasta_file {input.fasta} \
            --output_file {output.validation_file} \
            --min_contigs {params.chr_n}
        """

# Index the fasta file to gather contig length (used by msprime)
rule samtools_index:
    input:
        rules.input_validation.output.validation_file,
        fasta=lambda wildcards: config["samples"][wildcards.sample]["fasta_gz"]
    output:
        fai=temp(os.path.join(output_dir, "{sample}", temp_dir, "{sample}_full.fai"))
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    params: 
        out=os.path.join(output_dir, "{sample}", "01_chromosome_index")  
    container:
        "docker://registry.forge.inrae.fr/pangepop/mspangepop/samtool:1.21"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "samtools_index_benchmark.txt")
    priority: 10
    shell:
        """
        echo 'ðŸ”¹ MSpangepop -> Starting {wildcards.sample} indexing...' && 
        samtools faidx {input.fasta} && \
        mv {input.fasta}.fai {output.fai} && \
        echo 'âœ… MSpangepop -> {wildcards.sample} indexing successful.'
        if [ -f {input.fasta}.gzi ]; then 
            rm {input.fasta}.gzi
        fi
        """

# Simulate the coalescent and save it to a json file
rule msprime_simulation:    
    input:
        fai=rules.samtools_index.output
    output:
        json = temp(os.path.join(output_dir, "{sample}", temp_dir, "chr_{chromosome}", "chr_{chromosome}_msprime_simulation.json"))
    params:
        pop_size=lambda wildcards: config["samples"][wildcards.sample]["population_size"],
        mut_rate=lambda wildcards: config["samples"][wildcards.sample]["mutation_rate"],
        reco_rate=lambda wildcards: config["samples"][wildcards.sample]["recombination_rate"],
        n=lambda wildcards: config["samples"][wildcards.sample]["sample_size"],
        out=lambda wildcards: os.path.join(output_dir, f"{wildcards.sample}", temp_dir),
        model=lambda wildcards: config["samples"][wildcards.sample]["model"],
        readable_json=lambda wildcards: config["samples"][wildcards.sample].get("readable_json", False), 
        seed=lambda wildcards: config["samples"][wildcards.sample].get("seed", None) 
    resources:
        mem_mb=lambda wildcards: int(200000 * memory_multiplier),
        time="60:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "msprime_chr_{chromosome}_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    priority: 10
    shell:
        """
        python3 workflow/scripts/msprime_simulation.py \
            -fai {input.fai} \
            -p {params.pop_size} \
            -mu {params.mut_rate} \
            -r {params.reco_rate} \
            -n {params.n} \
            -o {params.out} \
            -c {wildcards.chromosome} \
            -mo {params.model} \
            --readable_json {params.readable_json} \
            --seed {params.seed}
        """

# Use the preorder traversal to get the order in which the mutations should be handeled, save a json
rule coalescent_traversal:
    input:
        json = rules.msprime_simulation.output.json
    output:
        traversal = temp(os.path.join(output_dir, "{sample}", temp_dir, "chr_{chromosome}", "chr_{chromosome}_traversal.json"))
    params:
        readable_json=lambda wildcards: config["samples"][wildcards.sample].get("readable_json", False) 
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    threads: 10
    priority: 9
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "coalescent_traversal_chr_{chromosome}_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    shell: 
        """
        python3 workflow/scripts/coalescent_traversal.py --json {input.json} \
            --chromosome {wildcards.chromosome} \
            --output_file {output.traversal} \
            --threads {threads} \
            --readable_json {params.readable_json}
        """

# Split fasta file at each recombination event
rule split_recombination:
    input:
        json = rules.msprime_simulation.output.json,
        fasta=lambda wildcards: config["samples"][wildcards.sample]["fasta_gz"]
    output:
        temp(os.path.join(output_dir, "{sample}", temp_dir, "chr_{chromosome}", "chr_{chromosome}_recombinations.fasta.gz"))
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "split_recombination_chr_{chromosome}_benchmark.txt")
    priority: 8
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    shell:
        """
        python3 workflow/scripts/split_recombination.py --json {input.json} \
            --fasta {input.fasta} \
            --chromosome {wildcards.chromosome} \
            --output {output} 
        """       

# Script to augment the traversal json file with muations position type and length
rule draw_variants:
    input:
        json = rules.coalescent_traversal.output.traversal
    output:
        os.path.join(output_dir, "{sample}", "pangenomes", "traversal", "chr_{chromosome}_augmented_traversal.json")
    params:
        sv_type_file = config.get("sv_type_file"),
        minimal_variant_size=lambda wildcards: config["samples"][wildcards.sample]["minimal_variant_size"],
        readable_json=lambda wildcards: config["samples"][wildcards.sample].get("readable_json", False) 
    threads: 10
    priority: 8
    resources:
        mem_mb=lambda wildcards: int(10000 * memory_multiplier),
        time="10:00:00"
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "generate_variant_{chromosome}_benchmark.txt")
    shell:
        """
        python3 workflow/scripts/draw_variants.py --json {input.json} \
            --yaml {params.sv_type_file} \
            --output {output} \
            --chromosome {wildcards.chromosome} \
            --threads {threads} \
            --minimal_variant_size {params.minimal_variant_size} \
            --readable_json {params.readable_json}
        """

rule graph_creation:
    input:
        splited_fasta=rules.split_recombination.output,
        augmented_traversal = rules.draw_variants.output,
    output:
        gfa = os.path.join(output_dir, "{sample}", "pangenomes", "chr_{chromosome}_graph.gfa"),
        recap = os.path.join(output_dir, "{sample}", "info", "chr_{chromosome}_recap.txt")
    params: 
        out_dir =  os.path.join(output_dir, "{sample}", "info")
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "create_graph_chr_{chromosome}_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    threads:4
    priority: 7
    shell:
        """
        python3 workflow/scripts/graph_creation.py \
            --splited_fasta {input.splited_fasta} \
            --augmented_traversal {input.augmented_traversal} \
            --output_file {output.gfa} \
            --sample {wildcards.sample} \
            --chromosome {wildcards.chromosome} \
            --recap_file {output.recap} \
            --variant_plot_dir {params.out_dir}
        """

onsuccess:
    print("âœ… MSpangepop -> Workflow completed successfully")
    shell("date")

onerror: 
    print("âŒ MSpangepop -> Workflow failed, check logs")
    shell("date")
