"""
Author: Lucien Piat
Institution: INRAe
Project: PangenOak
"""

configfile: ".config/masterconfig.yaml"

import os
import yaml

output_dir = config.get("output_dir", "results/")
temp_dir= config.get("tempfile_location", "00_temp/")
plot_dir = "01_plots/"
simulation_data = "02_simulation_data/"
graph  = "03_graph/"

# Retrieve memory multiplier from config
memory_multiplier = config.get("memory_multiplier", 1)

# Create explicit targets
def get_all_targets():
    targets = []
    for sample in config["samples"].keys():
        chr_n = config["samples"][sample]["chr_n"]
        # Add polished GFA files
        for chr_num in range(1, chr_n + 1):
            targets.append(os.path.join(output_dir, sample, graph, f"chr_{chr_num}_graph_polished.gfa"))
            targets.append(os.path.join(output_dir, sample, plot_dir, f"chr_{chr_num}_tree_plots", "visualization_complete.txt"))
        # Add global recap
        targets.append(os.path.join(output_dir, sample, simulation_data, f"{sample}_global_recap.txt"))
    return targets

rule all:
    input: get_all_targets()

# This rule is used to create a recap file for the workflow
rule global_recap:
    input:
        configfile= ".config/masterconfig.yaml"
    output:
        recap_file=os.path.join(output_dir, "{sample}", simulation_data, "{sample}_global_recap.txt")
    params:
        out=lambda wildcards: os.path.join(output_dir, wildcards.sample, simulation_data),
    resources:
        mem_mb=lambda wildcards: int(1000),
        time="00:10:00"
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    priority: 1
    shell:
        """
        python3 workflow/scripts/recap.py {input.configfile} \
            {params.out} \
            {wildcards.sample}
        """

# Check if the input file is usable if not, tell the user why
rule input_validation:
    input:
        fasta=lambda wildcards: config["samples"][wildcards.sample]["fasta_gz"]
    output:
        validation_file = temp(os.path.join(output_dir, "{sample}", temp_dir, "valid_input.tmp"))
    params:
        chr_n =lambda wildcards: config["samples"][wildcards.sample]["chr_n"]
    priority: 10
    resources:
        mem_mb=lambda wildcards: int(1000),
        time="00:10:00"
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    shell:
        """
        python3 workflow/scripts/input_validation.py --fasta_file {input.fasta} \
            --output_file {output.validation_file} \
            --min_contigs {params.chr_n}
        """

# Index the fasta file to gather contig length (used by msprime)
rule samtools_index:
    input:
        validation_file=rules.input_validation.output.validation_file,
        fasta=lambda wildcards: config["samples"][wildcards.sample]["fasta_gz"]
    output:
        fai=temp(os.path.join(output_dir, "{sample}", temp_dir, "{sample}_full.fai"))
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="1:00:00"
    container:
        "docker://registry.forge.inrae.fr/pangepop/mspangepop/samtool:1.21"
    priority: 10
    shell:
        """
        echo 'ðŸ”¹ MSpangepop -> Starting {wildcards.sample} indexing...' 
        samtools faidx {input.fasta} && \
        mv {input.fasta}.fai {output.fai} && \
        echo 'âœ… MSpangepop -> {wildcards.sample} indexing successful.'
        if [ -f {input.fasta}.gzi ]; then 
            rm {input.fasta}.gzi
        fi
        """

# Simulate the coalescent and save it to a json file
rule msprime_simulation:    
    input:
        fai=rules.samtools_index.output.fai
    output:
        json = temp(os.path.join(output_dir, "{sample}", temp_dir, "chr_{chromosome}", "chr_{chromosome}_msprime_simulation.json")),
        ancestry_ts = os.path.join(output_dir, "{sample}", simulation_data, "chr_{chromosome}", "ancestry_ts.trees"), 
        mutated_ts = os.path.join(output_dir, "{sample}", simulation_data, "chr_{chromosome}", "mutated_ts.trees"),
        recap = os.path.join(output_dir, "{sample}", simulation_data, "chr_{chromosome}", "msprime_recap.txt"),
    params:
        pop_size=lambda wildcards: config["samples"][wildcards.sample]["population_size"],
        mut_rate=lambda wildcards: config["samples"][wildcards.sample]["mutation_rate"],
        reco_rate=lambda wildcards: config["samples"][wildcards.sample]["recombination_rate"],
        n=lambda wildcards: config["samples"][wildcards.sample]["sample_size"],
        model=lambda wildcards: config["samples"][wildcards.sample]["model"],
        readable_json=lambda wildcards: config["samples"][wildcards.sample].get("readable_json", False), 
        seed=lambda wildcards: config["samples"][wildcards.sample].get("seed", None)
    resources:
        mem_mb=lambda wildcards: int(200000 * memory_multiplier),
        time="60:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "msprime_simulation_benchmark.txt")

    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    priority: 10
    shell:
        """
        python3 workflow/scripts/msprime_simulation.py \
            -fai {input.fai} \
            -p {params.pop_size} \
            -mu {params.mut_rate} \
            -r {params.reco_rate} \
            -n {params.n} \
            -c {wildcards.chromosome} \
            -mo {params.model} \
            --readable_json {params.readable_json} \
            --seed {params.seed} \
            --ancestry_ts {output.ancestry_ts} \
            --mutated_ts {output.mutated_ts} \
            --json {output.json} \
            --recap {output.recap}
        """

rule plot_msprime_simulation:
    input:
        ancestry_ts = rules.msprime_simulation.output.ancestry_ts,
        mutated_ts = rules.msprime_simulation.output.mutated_ts
    output:
        completion_flag = os.path.join(output_dir, "{sample}", plot_dir, "chr_{chromosome}_tree_plots", "visualization_complete.txt")
    params:
        out = lambda wildcards: os.path.join(
            output_dir, wildcards.sample, plot_dir, f"chr_{wildcards.chromosome}_tree_plots"
        )
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="01:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "plot_msprime_simulation_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    priority: 1
    shell:
        """
        python3 workflow/scripts/tree_visualizer.py {input.mutated_ts} \
            {input.ancestry_ts} \
            -o {params.out} \
            -c {wildcards.chromosome}
        echo "Visualization completed at $(date)" > {output.completion_flag}
        """

# Use the preorder traversal to get the order in which the mutations should be handled, save a json
rule coalescent_traversal:
    input:
        json = rules.msprime_simulation.output.json
    output:
        traversal = temp(os.path.join(output_dir, "{sample}", temp_dir, "chr_{chromosome}", "chr_{chromosome}_traversal.json"))
    params:
        readable_json=lambda wildcards: config["samples"][wildcards.sample].get("readable_json", False) 
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    threads: 10
    priority: 9
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "coalescent_traversal_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    shell: 
        """
        python3 workflow/scripts/coalescent_traversal.py --json {input.json} \
            --chromosome {wildcards.chromosome} \
            --output_file {output.traversal} \
            --threads {threads} \
            --readable_json {params.readable_json}
        """

# Split fasta file at each recombination event
rule split_recombination:
    input:
        json = rules.msprime_simulation.output.json,
        fasta=lambda wildcards: config["samples"][wildcards.sample]["fasta_gz"]
    output:
        split_fasta = temp(os.path.join(output_dir, "{sample}", temp_dir, "chr_{chromosome}", "chr_{chromosome}_recombinations.fasta.gz"))
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "split_recombination_benchmark.txt")
    priority: 8
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    shell:
        """
        python3 workflow/scripts/split_recombination.py --json {input.json} \
            --fasta {input.fasta} \
            --chromosome {wildcards.chromosome} \
            --output {output.split_fasta}
        """       

# Script to augment the traversal json file with mutations position type and length
rule draw_variants:
    input:
        traversal_json = rules.coalescent_traversal.output.traversal
    output:
        augmented_traversal = os.path.join(output_dir, "{sample}", graph, "traversal", "chr_{chromosome}_augmented_traversal.json")
    params:
        sv_type_file = config.get("sv_type_file"),
        minimal_variant_size=lambda wildcards: config["samples"][wildcards.sample]["minimal_variant_size"],
        readable_json=lambda wildcards: config["samples"][wildcards.sample].get("readable_json", False) 
    threads: 10
    priority: 8
    resources:
        mem_mb=lambda wildcards: int(10000 * memory_multiplier),
        time="10:00:00"
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "draw_variants_benchmark.txt")
    shell:
        """
        python3 workflow/scripts/draw_variants.py --json {input.traversal_json} \
            --yaml {params.sv_type_file} \
            --output {output.augmented_traversal} \
            --chromosome {wildcards.chromosome} \
            --threads {threads} \
            --minimal_variant_size {params.minimal_variant_size} \
            --readable_json {params.readable_json}
        """

# Create the graph from the augmented traversal (headache inducing script)
rule graph_creation:
    input:
        split_fasta=rules.split_recombination.output.split_fasta,
        augmented_traversal = rules.draw_variants.output.augmented_traversal,
    output:
        gfa = os.path.join(output_dir, "{sample}", graph, "chr_{chromosome}_graph.gfa"),
        recap = os.path.join(output_dir, "{sample}", simulation_data, "chr_{chromosome}","graph_creation_recap.txt")
    params:
        out_dir = lambda wildcards: os.path.join(output_dir, wildcards.sample, plot_dir)
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "graph_creation_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    threads: 1
    priority: 7
    shell:
        """
        python3 workflow/scripts/graph_creation.py \
            --splited_fasta {input.split_fasta} \
            --augmented_traversal {input.augmented_traversal} \
            --output_file {output.gfa} \
            --sample {wildcards.sample} \
            --chromosome {wildcards.chromosome} \
            --recap_file {output.recap} \
            --variant_plot_dir {params.out_dir}
        """

# This merges the nodes that can be merged in the GFA file
rule gfa_merge:
    input:
        initial_gfa = rules.graph_creation.output.gfa
    output:
        polished_gfa = os.path.join(output_dir, "{sample}", graph, "chr_{chromosome}_graph_polished.gfa")
    resources:
        mem_mb=lambda wildcards: int(50000 * memory_multiplier),
        time="10:00:00"
    benchmark:
        os.path.join(output_dir, "{sample}", "benchmark", "chr_{chromosome}", "gfa_merge_benchmark.txt")
    container:
        "oras://registry.forge.inrae.fr/pangepop/mspangepop/msprime_box:latest"
    threads: 4
    priority: 7
    shell:
        """
        python3 workflow/scripts/gfa_merge.py  \
            {input.initial_gfa} \
            {output.polished_gfa} \
            --threads {threads}
        """

onsuccess:
    print("âœ… MSpangepop -> Workflow completed successfully")
    shell("date")

onerror: 
    print("âŒ MSpangepop -> Workflow failed, check logs")
    shell("date")